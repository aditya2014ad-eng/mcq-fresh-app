<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />

<title>MCQ Q-Bank</title>

<!-- PWA manifest & theme -->
<link rel="manifest" href="manifest.json?v=5">
<meta name="theme-color" content="#1f6feb">
<!-- Optional favicons (ensure these files exist in the same folder) -->
<link rel="icon" type="image/png" sizes="192x192" href="mcq icon.png">
<link rel="icon" type="image/png" sizes="512x512" href="logo 2.png">

<style>
  :root{
    --bg:#f9f9f9; --ink:#222;
    --header-bg:#1f6feb; --header-ink:#ffffff;
    --card-bg:#ffffff; --border:#dddddd;
    --opt-bg:#f5f5f5;
    --pill-bg:#ffffff; --pill-ink:#1f6feb;
  }
  [data-theme="dark"]{
    --bg:#0f1115; --ink:#e6e6e6;
    --header-bg:#111827; --header-ink:#e6e6e6;
    --card-bg:#171a21; --border:#2a2e3a;
    --opt-bg:#0f1219;
    --pill-bg:#0f1219; --pill-ink:#e6e6e6;
  }

  *{ box-sizing:border-box }
  body { margin:0; font-family: system-ui, sans-serif; background:var(--bg); color:var(--ink); }
  header { display:flex; justify-content:space-between; align-items:center; padding:12px 18px; background:var(--header-bg); color:var(--header-ink); position:sticky; top:0; z-index:10; }
  header .brand { display:flex; align-items:center; gap:12px; }
  header img { width:64px; height:64px; border-radius:12px; background:#fff; padding:6px; box-shadow:0 4px 14px rgba(0,0,0,.18); }
  header h1 { margin:0; font-size:22px; }

  .toolbar { display:flex; gap:10px; align-items:center; }
  .pill { background:var(--pill-bg); color:var(--pill-ink); padding:8px 12px; border-radius:10px; border:1px solid var(--border); cursor:pointer; font-size:14px; }
  .pill:active{ transform:translateY(1px); }

  main { max-width:900px; margin:20px auto; padding:12px; }
  .card { background:var(--card-bg); border:1px solid var(--border); border-radius:12px; padding:16px; margin-bottom:18px; }
  .row { display:flex; gap:10px; flex-wrap:wrap; }

  textarea { width:100%; min-height:260px; padding:10px; font-size:15px; border-radius:10px; border:1px solid var(--border); background:var(--opt-bg); color:var(--ink); }

  .q { padding:12px; border:1px solid var(--border); border-radius:12px; margin:10px 0; background:var(--card-bg); }
  .q > div:first-child { font-weight:600; margin-bottom:6px; }
  .opts { list-style:none; padding:0; margin:0; display:grid; gap:8px; }
  .opt { padding:8px; border:1px solid var(--border); border-radius:10px; background:var(--opt-bg); }
  .opt.correct { border-color:#2e7d32; }
  .opt.wrong { border-color:#c62828; }
  /* Tag editor UI */
  .metaRow{display:flex;gap:8px;align-items:center;flex-wrap:wrap;margin-top:8px}
  .chip{display:inline-flex;align-items:center;gap:6px;padding:4px 8px;border:1px solid var(--border);border-radius:999px;background:var(--opt-bg);font-size:12px}
  .chip button{border:none;background:transparent;cursor:pointer;font-size:14px;line-height:1}
  .metaRow input[type="text"]{padding:6px 8px;border:1px solid var(--border);border-radius:8px;background:var(--opt-bg);color:var(--ink)}
  .metaRow select,.metaRow input[type="checkbox"]{padding:6px 8px;border:1px solid var(--border);border-radius:8px;background:var(--opt-bg);color:var(--ink)}
</style>
</head>
<body>

<header>
  <div class="brand">
    <img src="mcq icon.png" alt="Logo">
    <h1>MCQ Q-Bank</h1>
  </div>
  <div class="toolbar">
    <button id="themeToggle" class="pill" title="Toggle light/dark">🌙</button>
    <button id="installBtn" class="pill" style="display:none" title="Install as app">📥 Install</button>
    <span id="score" class="stats" style="margin-right:10px"></span>
    <span class="muted">Text</span>
    <div>
      <input id="mins" type="number" value="20" style="width:60px"> 
      <button id="tStart" class="pill">Start</button>
      <button id="tPause" class="pill">Pause</button>
      <button id="tReset" class="pill">Reset</button>
      <b id="tDisp">20:00</b>
    </div>
  </div>
</header>

<main>
  <div class="card">
    <p class="muted" style="margin:8px 0 6px"><b>Paste text MCQs</b></p>

    <div class="row" style="margin-top:8px">
      <input id="setTitle" placeholder="Saved set title" style="flex:1 1 320px" />
      <button id="saveSet" class="pill">💾 Save Set</button>
      <select id="savedList" style="min-width:160px"></select>
      <button id="deleteSet" class="pill">🗑️ Delete Set</button>
      <button id="exportSet" class="pill">⬇️ Export Set</button>
      <button id="exportAll" class="pill">⬇️ Export All</button>
      <button id="exportNormalized" class="pill">⬇️ Export Current (with meta)</button>
      <input id="importSetFile" type="file" accept=".json" style="display:none" />
      <button id="importSet" class="pill">⬆️ Import Set</button>
      <input id="importBankFile" type="file" accept=".json" style="display:none" />
      <button id="importBank" class="pill">⬆️ Import Bank</button>
    </div>

    <div class="row" style="margin-top:8px">
      <input id="txtFile" type="file" accept=".txt,.md" />
      <button id="loadBtn" class="pill">📂 Load File</button>
      <button id="exampleBtn" class="pill">✨ Insert Example</button>
    </div>

    <textarea id="raw"></textarea>
    <div class="row" style="margin-top:10px">
      <button id="cleanBtn" class="pill">🧽 Clean</button>
      <button id="clearBtn" class="pill">🗑️ Clear box</button>
      <button id="parseBtn" class="pill">▶️ Parse → Start Quiz</button>
    </div>
    <div id="errBox" style="color:red;margin-top:10px"></div>
  </div>

  <div class="card" id="quizCard" style="display:none">
    <div id="quiz"></div>
  </div>

  <div class="card">
    <div class="row">
      <button id="finishBtn" class="pill" disabled>✅ Finish & Score</button>
      <button id="shuffleQ" class="pill">🔀 Shuffle Questions</button>
      <button id="shuffleO" class="pill">🔁 Shuffle Options</button>
      <button id="hardReset" class="pill">♻️ Reset</button>
    </div>
  </div>
</main>

<script>
const rawEl=document.getElementById('raw');
const quizCard=document.getElementById('quizCard');
const quizEl=document.getElementById('quiz');
const scoreEl=document.getElementById('score');
const txtFile = document.getElementById('txtFile');
const loadBtn = document.getElementById('loadBtn');

// ---- Global quiz state ----
let QUIZ = [];
let ANSWERS = {};
let FINISHED = false;

// ---- Saved sets (localStorage) ----
const LS_SETS_KEY = 'mcq-sets-v1';
function getSets(){ try { return JSON.parse(localStorage.getItem(LS_SETS_KEY)||'{}')||{}; } catch { return {}; } }
function putSets(sets){ localStorage.setItem(LS_SETS_KEY, JSON.stringify(sets)); }
function refreshSavedList(){
  const sel = document.getElementById('savedList');
  if (!sel) return;
  const sets = getSets();
  const titles = Object.keys(sets).sort((a,b)=>a.localeCompare(b));
  const current = sel.value;
  sel.innerHTML = '<option value="">Saved sets…</option>' +
                  titles.map(t=>`<option value="${t.replace(/"/g,'&amp;quot;')}">${t}</option>`).join('');
  if (current && titles.includes(current)) sel.value = current;
}
refreshSavedList();

// ---- Load file into textarea ----
(function bindFileLoader(){
  if (!txtFile) return;

  async function readPickedFile(file){
    if (!file) return;
    try {
      let text = await file.text();
      // optional: normalize the content for cleaner parsing
      text = normalize(text);
      rawEl.value = text;

      // Try to use filename as the default set title (without extension)
      const setTitleEl = document.getElementById('setTitle');
      if (setTitleEl && file.name) {
        const base = file.name.replace(/\.[^.]+$/, '').replace(/[_\-]+/g, ' ').trim();
        if (base && !setTitleEl.value) setTitleEl.value = base.slice(0, 60);
      }
    } catch (e) {
      const err = document.getElementById('errBox');
      if (err) err.textContent = 'Failed to read file: ' + (e?.message || e);
    }
  }

  // When user picks a file, read it immediately
  txtFile.addEventListener('change', (e)=>{
    const f = e.target.files && e.target.files[0];
    readPickedFile(f);
  });

  // Make the 'Load File' button open the file picker (in case user prefers button)
  if (loadBtn) {
    loadBtn.onclick = () => txtFile && txtFile.click();
  }
})();

// Save / load / delete / export
(function bindSavedSetButtons(){
  const setTitle = document.getElementById('setTitle');
  const savedList = document.getElementById('savedList');
  const saveBtn   = document.getElementById('saveSet');
  const delBtn    = document.getElementById('deleteSet');
  const exportBtn = document.getElementById('exportSet');
  const exportAll = document.getElementById('exportAll');

  function downloadText(filename, text){
    const blob = new Blob([text], { type:'text/plain' });
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = filename;
    a.click();
    setTimeout(()=>URL.revokeObjectURL(a.href), 1000);
  }

  if (saveBtn) saveBtn.onclick = ()=>{
    const title = (setTitle?.value||'').trim();
    const text  = (rawEl?.value||'').trim();
    if (!text) { alert('Nothing to save'); return; }
    if (!title){ alert('Enter a title'); return; }
    const sets = getSets();
    sets[title] = text;
    putSets(sets);
    refreshSavedList();
    savedList.value = title;
  };

  if (savedList) savedList.onchange = ()=>{
    const t = savedList.value;
    const sets = getSets();
    if (t && sets[t]){ rawEl.value = sets[t]; setTitle.value = t; }
  };

  if (delBtn) delBtn.onclick = ()=>{
    const t = savedList?.value || setTitle?.value || '';
    if (!t) { alert('Pick a saved set'); return; }
    const sets = getSets();
    if (!sets[t]) { alert('No such saved set'); return; }
    delete sets[t];
    putSets(sets);
    refreshSavedList();
    savedList.value = '';
  };

  if (exportBtn) exportBtn.onclick = ()=>{
    const t = savedList?.value || setTitle?.value || '';
    const sets = getSets();
    if (!t || !sets[t]) { alert('Pick a saved set'); return; }
    downloadText(`${t}.md`, sets[t]);
  };

  if (exportAll) exportAll.onclick = ()=>{
    const sets = getSets();
    const json = JSON.stringify(sets, null, 2);
    const stamp = new Date().toISOString().replace(/[:.]/g,'-');
    downloadText(`mcq_bank_${stamp}.json`, json);
  };
})();

const root=document.documentElement;
const THEME_KEY='mcq-theme';
if (!localStorage.getItem(THEME_KEY)) { document.documentElement.setAttribute('data-theme','light'); }
(function initTheme(){
  const saved=localStorage.getItem(THEME_KEY)||'light';
  root.setAttribute('data-theme', saved);
  const btn=document.getElementById('themeToggle');
  btn.textContent = saved==='light' ? '🌙' : '🌞';
  btn.onclick = () => {
    const next = (root.getAttribute('data-theme')==='light') ? 'dark' : 'light';
    root.setAttribute('data-theme', next);
    localStorage.setItem(THEME_KEY, next);
    btn.textContent = next==='light' ? '🌙' : '🌞';
  };
})();

function normalize(text){
  if (!text) return '';
  let t = String(text)
    .replace(/\uFEFF/g,'')                 // BOM
    .replace(/[\u200B-\u200D\u2060]/g,'')  // zero‑width
    .replace(/\r\n?/g,'\n')                // CRLF → LF
    .replace(/\u00A0/g,' ')                // NBSP
    .replace(/[“”]/g,'"').replace(/[‘’]/g,"'")
    .replace(/[–—]/g,'-')
    .replace(/^\s*(?:\*{3,}|-{3,}|_{3,})\s*$/gm,''); // horizontal rules

  // Insert newlines BEFORE inline option markers (A) / b. / C: with optional number/list prefix)
  t = t.replace(
    /(\S)\s+((?:\d+\s*[\)\.\-]\s*)?(?:[-–—•]\s*)?(?:\*\*)?\s*\(?[A-Da-d]\)?\s*[\)\.:]\s+(?=\S))/g,
    '$1\n$2'
  );
  // Newlines before Answer/Explanation labels (with possible bold, junk before colon)
  t = t.replace(
    /(\S)\s+((?:\*\*)?\s*(?:ans|answer|correct|exp|explanation)\b[^:]*[:=\-]\s*(?=\S))/ig,
    '$1\n$2'
  );

  // If "Answer:" is followed by a bare letter stuck to the same line without space (rare OCR),
  // add a space so our regex picks it up.
  t = t.replace(/(answer\b[^:]*[:=\-])([A-Da-d])\b/ig, '$1 $2');

  // Collapse trailing spaces and mega blank lines
  t = t.replace(/[ \t]+\n/g,'\n').replace(/\n{3,}/g,'\n\n').trim();
  return t;
}

// helpers for safe rendering and Markdown inline formatting
function escapeHtml(s){return String(s).replace(/[&<>"']/g,m=>({"&":"&amp;","<":"&lt;",">":"&gt;","\"":"&quot;","'":"&#39;"}[m]));}
function mdInline(s){
  s = escapeHtml(String(s||''));
  s = s.replace(/\*\*(.+?)\*\*/g,'<b>$1</b>');
  s = s.replace(/(^|[\s>])_(?!\s)([^_\n]+?)_(?=($|[\s<]))/g,'$1<i>$2</i>');
  s = s.replace(/`([^`]+)`/g,'<code>$1</code>');
  return s;
}

// Parse
function parseMCQ(text){
  window.__parseErrors = [];
  const T = normalize(text);
  const blocks = T.split(/\n{2,}/).map(b=>b.trim()).filter(Boolean);

  // Option lines like: "- A) foo", "a) bar", "B. baz", "(c) qux", "2) d: quux"
  const OPT_RE = /^\s*(?:\d+\s*[\)\.\-]\s*)?(?:[-–—•]\s*)?(?:\*\*)?\s*\(?([A-Da-d])\)?\s*[\)\.:\-]\s*(.+)$/;
  // Answer labels with bold/noise before colon: "**Answer**:", "Ans -", "correct:"
  const ANS_RE = /^\s*(?:\*\*)?\s*(?:ans|answer|correct)\b[^:]*[:=\-]\s*(.*)$/i;
  // Explanation labels (allow "exp:")
  const EXP_RE = /^\s*(?:\*\*)?\s*(?:exp|explanation)\b[^:]*[:=\-]\s*(.+)$/i;

  // ---- Metadata lines & inline tokens (E/M/D, HYT, tags, id) ----
  const META_TAGS_RE = /^\s*(?:\*\*)?\s*(tags?|labels?)\s*:\s*(.+)$/i;        // Tags: cardio, pediatrics
  const META_ID_RE   = /^\s*(?:\*\*)?\s*(id|qid)\s*:\s*(.+)$/i;               // ID: Q-123
  const META_DIFF_RE = /^\s*(?:\*\*)?\s*(difficulty|level|d|diff)\s*:\s*(.+)$/i; // Difficulty: easy|medium|difficult|E/M/D
  const META_HYT_RE  = /^\s*(?:\*\*)?\s*(hyt|high\s*yield(?:\s*topic)?)\s*:\s*(.*)$/i; // HYT: true/yes

  // Inline tokens anywhere in text: [[tags: cardio, endocrine]] [[d:M]] [[hyt:true]]
  const META_INLINE  = /\[\[\s*(tags?|labels?|id|qid|difficulty|level|d|diff|hyt|flag|star|bookmark)\s*:\s*([^\]]*)\]\]/ig;

  function normalizeDifficulty(v){
    const s = String(v||'').trim().toLowerCase();
    if (/^(e|easy)$/i.test(s)) return 'easy';
    if (/^(m|med|medium)$/i.test(s)) return 'medium';
    if (/^(d|diff|hard|difficult)$/i.test(s)) return 'difficult';
    return '';
  }
  function toBool(v){
    const s = String(v||'').trim().toLowerCase();
    return !!(s === '' || /^(true|yes|y|1|⭐|\*|on|high|hyt)$/i.test(s));
    // empty value defaults to true so [[hyt:]] works
  }
  // Remove inline meta tokens from visible text but collect into meta object
  function absorbInlineMeta(str, meta){
    if (!str) return str;
    return str.replace(META_INLINE, (_all, key, val) => {
      key = String(key||'').toLowerCase();
      val = String(val||'').trim();

      if (key === 'tags' || key === 'labels'){
        const parts = val.split(/[,\|]/).map(s=>s.trim().toLowerCase()).filter(Boolean);
        meta.tags = Array.from(new Set([...(meta.tags||[]), ...parts]));
      } else if (key === 'id' || key === 'qid'){
        if (!meta.id) meta.id = val;
      } else if (key === 'difficulty' || key === 'level' || key === 'd' || key === 'diff'){
        const d = normalizeDifficulty(val);
        if (d) meta.difficulty = d;
      } else if (key === 'hyt' || key === 'flag' || key === 'star' || key === 'bookmark'){
        meta.hyt = toBool(val);
      }
      return ''; // strip token from rendered text
    });
  }

  // Remove common leading "Q#/Q./1)" and markdown heading hashes
  const STRIP_Q_PREFIX = (s) => String(s)
      .replace(/^\s*#{1,6}\s*/, '')
      .replace(/^\s*(?:Q\s*\d*|Q|(\d+))\s*[\.\):]\s*/i, '')
      .trim();

  // --- Helper functions for answer/option cleaning & matching ---
  // Keep the intended A–D answer even if OCR added junk, markdown, etc.
  function cleanAnswerPayload(p){
    if (!p) return '';
    let s = String(p).trim();

    // Strip markdown and common wrappers
    s = s.replace(/\*\*|__/g, '').replace(/`/g, '');

    // Remove surrounding quotes/brackets and trailing references e.g. [1], (ref)
    s = s.replace(/^[\s"'\(\[\{]+/, '').replace(/[\s"'\)\]\}]+$/, '');
    s = s.replace(/[\(\[\{][^()\[\]{}]*[\)\]\}]\s*$/g, '');

    // Normalize separators like "Ans wer: B" -> try to keep only payload
    s = s.replace(/\b(answer|ans|correct)\b[^:]*:\s*/i, '');

    // If starts with "B)"/"B."/"(B)" capture the letter
    let m = s.match(/^\s*\(?\s*([A-Da-d])\s*\)?\s*[\)\.\-:]/);
    if (m) return m[1].toUpperCase();

    // If contains a standalone letter near the end (handles OCR junk)
    m = s.match(/([A-Da-d])(?:\s*[\*\)\]\.:\-]*)\s*$/);
    if (m) return m[1].toUpperCase();

    // Any isolated letter token
    m = s.match(/\b([A-Da-d])\b/);
    if (m) return m[1].toUpperCase();

    // Otherwise return the cleaned text so we can fuzzy-match to option text
    return s.trim();
  }

  function resolveCorrectIndex(options, rawPayload){
    if (!options?.length) return -1;

    const payload = cleanAnswerPayload(rawPayload);

    // If payload is A–D letter, return directly
    if (/^[A-D]$/.test(payload)) {
      const idx = payload.charCodeAt(0) - 65;
      return (idx >= 0 && idx < options.length) ? idx : -1;
    }

    // Normalize function for better fuzzy matching
    const norm = (s) => String(s||'')
      .toLowerCase()
      .replace(/\*\*|__/g,'')
      .replace(/`/g,'')
      .replace(/[“”]/g,'"').replace(/[‘’]/g,"'")
      .replace(/[–—]/g,'-')
      .replace(/[\s\.\,\;\:\!\?\(\)\[\]\{\}"'`]+/g,' ') // punctuation -> space
      .replace(/\s+/g,' ')
      .trim();

    const want = norm(payload);

    // Build candidate scores against each option
    let bestIdx = -1;
    let bestScore = -1;

    options.forEach((o, i) => {
      const n = norm(o);

      if (!n || !want) return;

      // Exact match
      if (n === want) {
        if (bestScore < 100) { bestScore = 100; bestIdx = i; }
        return;
      }

      // Contains either way
      if (n.includes(want) || want.includes(n)) {
        const score = Math.min(n.length, want.length); // longer overlap = higher
        if (score > bestScore) { bestScore = score; bestIdx = i; }
        return;
      }

      // Token overlap (Jaccard-like)
      const a = new Set(n.split(' '));
      const b = new Set(want.split(' '));
      const inter = [...a].filter(t => b.has(t)).length;
      const union = new Set([...a, ...b]).size || 1;
      const j = inter / union; // 0..1
      const score = j * 50 + inter; // weight
      if (score > bestScore) { bestScore = score; bestIdx = i; }
    });

    return bestIdx;
  }

  const items = [];

  for (const rawBlock of blocks){
    // Break into lines; if a single long line, try to split by option markers again
    let lines = rawBlock.split('\n').map(l=>l.trim()).filter(Boolean);
    if (lines.length === 1){
      const para = lines[0].replace(/\s{2,}/g,' ');
      const split = para.split(/\s(?=(?:\d+\s*[\)\.\-]\s*)?(?:[-–—•]\s*)?(?:\*\*)?\s*\(?[A-Da-d]\)?\s*[\)\.:]\s)/);
      if (split.length > 1) lines = [ split.shift(), ...split ];
    }

    // 1) Build stem until first option/label line
    const stemParts = [];
    while (lines.length && !OPT_RE.test(lines[0]) && !ANS_RE.test(lines[0]) && !EXP_RE.test(lines[0])){
      stemParts.push(STRIP_Q_PREFIX(lines.shift()));
    }
    let stem = stemParts.join(' ').trim();

    // 2) Options (A–D); keep order
    const optLines = [];
    while (lines.length && OPT_RE.test(lines[0])){
      const m = lines.shift().match(OPT_RE);
      optLines.push((m && m[2] ? m[2] : '').trim());
    }
    // Normalize option text for robust matching
    const options = optLines.map(s =>
      String(s || '')
        .replace(/\*\*|__/g,'')
        .replace(/`/g,'')
        .replace(/[“”]/g,'"').replace(/[‘’]/g,"'")
        .replace(/[–—]/g,'-')
        .replace(/\s+/g,' ')
        .trim()
    );

    // 3) Answer + Explanation (any order, can span paragraphs)
    let ansPayload = '', explanation = '';
    let awaitingAnswerContinuation = false;
    while (lines.length){
      const L = lines.shift();
      let m;

      // Answer label
      if ((m = L.match(ANS_RE))){
        ansPayload = (m[1] ?? '').trim();

        // If payload is empty, try to read from the very next line(s)
        if (!ansPayload && lines.length){
          const peek = (s) => String(s || '').trim();
          let nxt = peek(lines[0]);

          // Case 1: next line is a bare letter like "B" or "(b)" or "B)" etc.
          let mm = nxt.match(/^\s*\(?\s*([A-Da-d])\s*\)?\s*[\)\.:\-]?\s*$/);
          if (mm){
            ansPayload = mm[1].toUpperCase();
            lines.shift(); // consume the line
            continue;
          }

          // Case 2: next line is a full option line, e.g. "- B) Glucocorticoids"
          mm = nxt.match(OPT_RE);
          if (mm){
            // Prefer the option LETTER if present; otherwise the option text for fuzzy match
            ansPayload = (mm[1] ? mm[1].toUpperCase() : (mm[2] || '')).trim();
            lines.shift(); // consume the line
            continue;
          }

          // Case 3: next line is free text (e.g., the exact option phrase)
          if (nxt){
            ansPayload = nxt;
            lines.shift();
            continue;
          }
        }
        // If we had non-empty payload, proceed
        continue;
      }

      // Explanation label
      if ((m = L.match(EXP_RE))){
        explanation = (m[1] || '').trim();
        // absorb following free-text lines into explanation until another label is hit
        while (lines.length && !ANS_RE.test(lines[0]) && !OPT_RE.test(lines[0])){
          const cont = lines[0].trim();
          if (cont) { explanation += (explanation ? ' ' : '') + cont; }
          lines.shift();
        }
        continue;
      }

      // Continuations:
      if (explanation){
        explanation += ' ' + L;
      } else if (options.length === 0){
        // If options were never captured (rare paragraph style), keep extending stem
        stem += (stem ? ' ' : '') + STRIP_Q_PREFIX(L);
      }
    }

    // Rescue: if stem missing, rebuild from non-option/label content
    if (!stem){
      const rescue = rawBlock.split('\n')
        .filter(line => !OPT_RE.test(line) && !ANS_RE.test(line) && !EXP_RE.test(line))
        .map(STRIP_Q_PREFIX).join(' ').trim();
      stem = rescue;
    }

    // Need at least 2 options + non-empty stem
    if (!stem || options.length < 2) continue;

    // Resolve correct option index
    let correctIndex = -1;
    if (ansPayload){
      let payload = ansPayload;
      payload = cleanAnswerPayload(payload);
      correctIndex = resolveCorrectIndex(options, /^[A-Da-d]$/.test(payload) ? payload.toUpperCase() : payload);
    }
    if (correctIndex < 0) {
      // Do NOT default to A. Surface an error and skip this item.
      const previewStem = (stem || '').slice(0, 80);
      const previewAns  = (ansPayload || '').slice(0, 40);
      console.warn('Answer could not be resolved for:', previewStem, 'payload:', previewAns);
      try {
        (window.__parseErrors ||= []).push(`Could not resolve answer for: "${previewStem}" (Answer: ${previewAns || '—'})`);
      } catch {}
      continue;
    }

    items.push({ stem, options, correctIndex, explanation });
  }

  try {
    const eb = document.getElementById('errBox');
    if (eb && window.__parseErrors.length) {
      eb.style.color = 'red';
      eb.innerHTML = '<b>Parsing issues:</b><br>' + window.__parseErrors.map(e => '• ' + e).join('<br>');
    }
  } catch {}
  return items;
}

function renderQuiz(){
  quizEl.innerHTML=QUIZ.map((q,i)=>{
    // Ensure meta is initialized for each question
    META.ensureItemMeta(q);
    const meta = q.meta || {};
    // Difficulty select options
    const diffOpts = ['','easy','medium','difficult'];
    const diffLabels = {'':'—','easy':'Easy','medium':'Medium','difficult':'Difficult'};
    // Tag chips
    const tagChips = (meta.tags||[]).map(tag =>
      `<span class="chip">${escapeHtml(tag)} <button title="Remove tag" onclick="META.removeItemTag(${i},'${escapeHtml(tag)}')">❌</button></span>`
    ).join(' ');
    // Tag input id for this question
    const tagInputId = `tagInput${i}`;
    // Difficulty select
    const diffSel = `<select onchange="META.setItemDifficulty(${i}, this.value)">
      ${diffOpts.map(d => `<option value="${d}"${meta.difficulty===d?' selected':''}>${diffLabels[d]}</option>`).join('')}
    </select>`;
    // HYT checkbox
    const hytChk = `<label style="display:inline-flex;align-items:center;gap:2px;">
      <input type="checkbox" onchange="META.setItemHYT(${i}, this.checked)"${meta.hyt ? ' checked' : ''}> HYT
    </label>`;
    // Tag adder
    const tagAdder = `<input type="text" id="${tagInputId}" placeholder="Add tag" style="width:90px;">
      <button title="Add tag" onclick="META.addItemTag(${i}, document.getElementById('${tagInputId}').value);document.getElementById('${tagInputId}').value='';">➕</button>`;
    // Meta controls row
    const metaRow = `<div class="metaRow">
      <span>Difficulty: ${diffSel}</span>
      ${hytChk}
      <span>Tags: ${tagAdder} ${tagChips}</span>
    </div>`;
    return `
    <div class="q">
      <div>${i+1}. ${mdInline(q.stem)}</div>
      <ul class="opts">
        ${q.options.map((opt,j)=>{
          let cls="opt";
          if(FINISHED){ if(j===q.correctIndex) cls+=" correct"; else if(ANSWERS[i]===j) cls+=" wrong"; }
          return `<li class="${cls}">
            <label><input type="radio" name="q${i}" value="${j}" ${ANSWERS[i]===j?"checked":""} ${FINISHED?"disabled":""}>
            ${String.fromCharCode(65+j)}) ${mdInline(String(opt || ''))}</label>
          </li>`;
        }).join("")}
      </ul>
      ${FINISHED?`<div><b>Explanation:</b> ${mdInline(q.explanation||"")}</div>`:""}
      ${metaRow}
    </div>
    `;
  }).join("");
  quizEl.querySelectorAll('input[type="radio"]').forEach(inp=>{
    inp.onchange=()=>{ const idx=+inp.name.replace("q",""); ANSWERS[idx]=+inp.value; updateScore(); };
  });
}
function updateScore(){
  let c=0,w=0,s=0;
  QUIZ.forEach((q,i)=>{ const a=ANSWERS[i]; if(a==null) s++; else if(a===q.correctIndex) c++; else w++; });
  scoreEl.textContent=`Answered: ${QUIZ.length-s}/${QUIZ.length} • Correct: ${c} • Wrong: ${w}`;
}

// UI
document.getElementById('parseBtn').onclick=()=>{
  const err = document.getElementById('errBox');
  err.textContent = '';
  QUIZ = parseMCQ(rawEl.value||"");
  // Show errBox if errors were collected
  const eb = document.getElementById('errBox');
  if (eb && window.__parseErrors && window.__parseErrors.length) {
    eb.style.display = 'block';
  }
  if (!QUIZ.length){
    if (!window.__parseErrors || !window.__parseErrors.length) {
      err.textContent = "Parsing failed. Ensure options are A)/B)/C)/D) and include an Answer:. If this still fails, paste one sample and I'll tune it.";
    }
    quizCard.style.display="none";
    scoreEl.textContent="";
    return;
  }

  // Enable Finish button and auto-start timer (1 min per question, min 1)
  const finishBtnEl = document.getElementById('finishBtn');
  if (finishBtnEl) finishBtnEl.disabled = false;

  const perQ = Math.max(1, QUIZ.length);
  const minsInput = document.getElementById('mins');
  if (minsInput) minsInput.value = perQ;
  try { startTimer(perQ); } catch(e){}

  quizCard.style.display="block";
  FINISHED=false; ANSWERS={};
  renderQuiz(); updateScore();
};
document.getElementById('finishBtn').onclick = () => {
  // Pause/stop the countdown but keep the remaining time visible
  try { clearInterval(tick); } catch {}
  tick = null;

  // Show results
  FINISHED = true;
  renderQuiz();
};
document.getElementById('shuffleQ').onclick = () => {
  if (!QUIZ.length) return;
  // Fisher–Yates
  for (let i = QUIZ.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [QUIZ[i], QUIZ[j]] = [QUIZ[j], QUIZ[i]];
  }
  // Clear previous picks because indices changed
  ANSWERS = {};
  FINISHED = false;
  renderQuiz();
  updateScore();
};

document.getElementById('shuffleO').onclick = () => {
  if (!QUIZ.length) return;
  QUIZ.forEach(q => {
    const order = q.options.map((_, idx) => idx);
    // Fisher–Yates on the index order
    for (let i = order.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [order[i], order[j]] = [order[j], order[i]];
    }
    // Reorder options using the shuffled indices
    q.options = order.map(idx => q.options[idx]);
    // Update the correctIndex to the new position of the former correct option
    q.correctIndex = order.indexOf(q.correctIndex);
  });
  // Clear any previous selections since option positions changed
  ANSWERS = {};
  FINISHED = false;
  renderQuiz();
  updateScore();
};
document.getElementById('hardReset').onclick=()=>{QUIZ=[];ANSWERS={};FINISHED=false;quizCard.style.display="none";scoreEl.textContent="";};
document.getElementById('exampleBtn').onclick=()=>{rawEl.value="Q1. Example question?\nA) One\nB) Two\nC) Three\nD) Four\nAnswer: B\nExplanation: Demo";};
document.getElementById('cleanBtn').onclick=()=>{rawEl.value=normalize(rawEl.value);};
document.getElementById('clearBtn').onclick=()=>{ rawEl.value=''; rawEl.focus(); };

// Timer
const mins=document.getElementById('mins'),tDisp=document.getElementById('tDisp'); let tick=null,deadline=0;
const fmt=s=>{ const ss=Math.max(0, Math.floor(s)); return `${String(Math.floor(ss/60)).padStart(2,'0')}:${String(ss%60).padStart(2,'0')}`; };
function startTimer(m){deadline=Date.now()+m*60*1000;if(tick)clearInterval(tick);tick=setInterval(()=>{let s=Math.max(0,Math.ceil((deadline-Date.now())/1000));tDisp.textContent=fmt(s);if(s<=0){clearInterval(tick);}},1000);}
document.getElementById('tStart').onclick=()=>startTimer(+mins.value||20);
document.getElementById('tPause').onclick=()=>clearInterval(tick);
document.getElementById('tReset').onclick=()=>{clearInterval(tick);tDisp.textContent=fmt((+mins.value||20)*60); try{ updateScore(); }catch{};};
</script>

<script id="meta-helpers">
/* ===================== MCQ Metadata Helpers (E/M/D, HYT, tags, ID) ===================== */
(function(){
  // Public API (attached to window for now so later UI can call these)
  const API = {};

  function emptyMeta(){ return { difficulty:'', hyt:false, tags:[], id:'' }; }
  function cloneMeta(m){
    if (!m) return emptyMeta();
    return {
      difficulty: (m.difficulty||'').toString(),
      hyt: !!m.hyt,
      tags: Array.isArray(m.tags) ? Array.from(new Set(m.tags.map(__normTag))).filter(Boolean) : [],
      id: (m.id||'').toString()
    };
  }
  function __normTag(t){ return String(t||'').trim().toLowerCase().replace(/\s+/g,' '); }

  // Convert meta → compact inline token string that can live inside question or explanation
  // Example:  [[d:M]] [[hyt:true]] [[tags: cardio, endocrine]] [[id: Q-123]]
  function metaToInline(meta){
    const m = cloneMeta(meta);
    const parts = [];
    if (m.difficulty) parts.push(`[[d:${m.difficulty}]]`);
    if (m.hyt)        parts.push(`[[hyt:true]]`);
    if (m.tags?.length) parts.push(`[[tags: ${m.tags.join(', ')}]]`);
    if (m.id)         parts.push(`[[id:${m.id}]]`);
    return parts.join(' ');
  }

  // Regexes for line-based meta and inline meta tokens
  const META_LINE = {
    tags: /^\s*(?:\*\*)?\s*(?:tags?|labels?)\s*:\s*(.+)$/i,
    id:   /^\s*(?:\*\*)?\s*(?:id|qid)\s*:\s*(.+)$/i,
    diff: /^\s*(?:\*\*)?\s*(?:difficulty|level|d|diff)\s*:\s*(.+)$/i,
    hyt:  /^\s*(?:\*\*)?\s*(?:hyt|high\s*yield(?:\s*topic)?)\s*:\s*(.*)$/i
  };
  const META_INLINE = /\[\[\s*(tags?|labels?|id|qid|difficulty|level|d|diff|hyt|flag|star|bookmark)\s*:\s*([^\]]*)\]\]/ig;

  function normalizeDifficulty(v){
    const s = String(v||'').trim().toLowerCase();
    if (/^(e|easy)$/i.test(s)) return 'easy';
    if (/^(m|med|medium)$/i.test(s)) return 'medium';
    if (/^(d|diff|hard|difficult)$/i.test(s)) return 'difficult';
    return '';
  }
  function toBool(v){
    const s = String(v||'').trim().toLowerCase();
    return !!(s === '' || /^(true|yes|y|1|⭐|\*|on|high|hyt)$/i.test(s));
  }

  // Extract meta from free text (both line-based and inline), returning cleaned text and a meta object
  function stripAndExtractMeta(text){
    let meta = emptyMeta();
    let body = String(text||'');

    // Pass 1: line-based meta lines — remove them from body
    const lines = body.split(/\r?\n/);
    const kept = [];
    for (const L of lines){
      let m;
      if ((m = L.match(META_LINE.tags))){
        const parts = String(m[1]||'').split(/[,\|]/).map(__normTag).filter(Boolean);
        meta.tags = Array.from(new Set([...(meta.tags||[]), ...parts]));
        continue;
      }
      if ((m = L.match(META_LINE.id))){
        meta.id = (m[1]||'').trim();
        continue;
      }
      if ((m = L.match(META_LINE.diff))){
        const d = normalizeDifficulty(m[1]||''); if (d) meta.difficulty = d;
        continue;
      }
      if ((m = L.match(META_LINE.hyt))){
        meta.hyt = toBool(m[1]||'');
        continue;
      }
      kept.push(L);
    }
    body = kept.join('\n');

    // Pass 2: inline tokens [[...]] — remove from body while absorbing values
    body = body.replace(META_INLINE, (_all, key, val) => {
      key = String(key||'').toLowerCase();
      val = String(val||'').trim();

      if (key === 'tags' || key === 'labels'){
        const parts = val.split(/[,\|]/).map(__normTag).filter(Boolean);
        meta.tags = Array.from(new Set([...(meta.tags||[]), ...parts]));
      } else if (key === 'id' || key === 'qid'){
        if (!meta.id) meta.id = val;
      } else if (key === 'difficulty' || key === 'level' || key === 'd' || key === 'diff'){
        const d = normalizeDifficulty(val);
        if (d) meta.difficulty = d;
      } else if (key === 'hyt' || key === 'flag' || key === 'star' || key === 'bookmark'){
        meta.hyt = toBool(val);
      }
      return ''; // strip token from visible text
    });

    // Tidy stray double spaces after stripping
    body = body.replace(/[ \t]{2,}/g,' ').replace(/\n{3,}/g,'\n\n').trim();
    return { text: body, meta };
  }

  function mergeMeta(base, add){
    const a = cloneMeta(base);
    const b = cloneMeta(add);
    return {
      difficulty: b.difficulty || a.difficulty,
      hyt: !!(a.hyt || b.hyt),
      tags: Array.from(new Set([...(a.tags||[]), ...(b.tags||[])])),
      id: b.id || a.id
    };
  }

  // Attach meta container to a quiz item if missing
  function ensureItemMeta(item){
    if (!item.meta) item.meta = emptyMeta();
    // normalize fields
    item.meta = cloneMeta(item.meta);
    return item.meta;
  }

  // --- Item update helpers (will be used by UI in the next step) ---
  function setItemDifficulty(idx, val){
    if (!Array.isArray(window.QUIZ)) return;
    const q = window.QUIZ[idx]; if (!q) return;
    const m = ensureItemMeta(q);
    m.difficulty = normalizeDifficulty(val);
    renderQuiz?.();
  }
  function setItemHYT(idx, bool){
    if (!Array.isArray(window.QUIZ)) return;
    const q = window.QUIZ[idx]; if (!q) return;
    const m = ensureItemMeta(q);
    m.hyt = !!bool;
    renderQuiz?.();
  }
  function addItemTag(idx, tag){
    tag = __normTag(tag);
    if (!tag) return;
    const q = window.QUIZ?.[idx]; if (!q) return;
    const m = ensureItemMeta(q);
    if (!m.tags.includes(tag)) m.tags.push(tag);
    renderQuiz?.();
  }
  function removeItemTag(idx, tag){
    tag = __normTag(tag);
    const q = window.QUIZ?.[idx]; if (!q) return;
    const m = ensureItemMeta(q);
    m.tags = (m.tags||[]).filter(t => t !== tag);
    renderQuiz?.();
  }

  // Expose
  API.emptyMeta = emptyMeta;
  API.cloneMeta = cloneMeta;
  API.metaToInline = metaToInline;
  API.stripAndExtractMeta = stripAndExtractMeta;
  API.mergeMeta = mergeMeta;
  API.ensureItemMeta = ensureItemMeta;
  API.setItemDifficulty = setItemDifficulty;
  API.setItemHYT = setItemHYT;
  API.addItemTag = addItemTag;
  API.removeItemTag = removeItemTag;

  window.META = API;
})();
</script>

</script>

<script>
// PWA install button logic (shows when site is installable over HTTPS/localhost)
(function(){
  let deferredPrompt = null;
  const btn = document.getElementById('installBtn');

  window.addEventListener('beforeinstallprompt', (e) => {
    // Prevent the mini-infobar on mobile and store event
    e.preventDefault();
    deferredPrompt = e;
    if (btn) btn.style.display = '';
  });

  if (btn) {
    btn.addEventListener('click', async () => {
      if (!deferredPrompt) return;
      deferredPrompt.prompt();
      try {
        const choice = await deferredPrompt.userChoice;
        // Hide button if accepted
        if (choice && choice.outcome === 'accepted') {
          btn.style.display = 'none';
        }
      } catch {}
      deferredPrompt = null;
    });
  }

  window.addEventListener('appinstalled', () => {
    if (btn) btn.style.display = 'none';
    console.log('PWA installed');
  });
})();
</script>

<script>
// Register Service Worker + background update checks + one-time auto-refresh on new version
if ('serviceWorker' in navigator) {
  (async function () {
    try {
      const reg = await navigator.serviceWorker.register('./sw.js');
      console.log('SW registered', reg.scope || '');

      // Pull updates when the tab becomes visible and every 10 minutes
      const check = () => reg.update().catch(()=>{});
      document.addEventListener('visibilitychange', () => {
        if (document.visibilityState === 'visible') check();
      });
      setInterval(check, 10 * 60 * 1000);

      // If the newly installed SW becomes active, refresh this page once
      let refreshed = false;
      navigator.serviceWorker.addEventListener('message', (e) => {
        if (e.data && e.data.type === 'SW_ACTIVE' && !refreshed) {
          refreshed = true;
          location.reload();
        }
      });
      navigator.serviceWorker.addEventListener('controllerchange', () => {
        if (!refreshed) { refreshed = true; location.reload(); }
      });
    } catch (err) {
      console.warn('SW registration/update issue:', err);
    }
  })();
}
</script>

</body>
</html>
