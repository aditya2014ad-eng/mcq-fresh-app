<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>MCQ Q-Bank</title>

<style>
  :root{
    --bg:#f9f9f9; --ink:#222;
    --header-bg:#1f6feb; --header-ink:#ffffff;
    --card-bg:#ffffff; --border:#dddddd;
    --opt-bg:#f5f5f5;
    --pill-bg:#ffffff; --pill-ink:#1f6feb;
  }
  [data-theme="dark"]{
    --bg:#0f1115; --ink:#e6e6e6;
    --header-bg:#111827; --header-ink:#e6e6e6;
    --card-bg:#171a21; --border:#2a2e3a;
    --opt-bg:#0f1219;
    --pill-bg:#0f1219; --pill-ink:#e6e6e6;
  }

  *{ box-sizing:border-box }
  body { margin:0; font-family: system-ui, sans-serif; background:var(--bg); color:var(--ink); }
  header { display:flex; justify-content:space-between; align-items:center; padding:12px 18px; background:var(--header-bg); color:var(--header-ink); position:sticky; top:0; z-index:10; }
  header .brand { display:flex; align-items:center; gap:12px; }
  header img { width:64px; height:64px; border-radius:12px; background:#fff; padding:6px; box-shadow:0 4px 14px rgba(0,0,0,.18); }
  header h1 { margin:0; font-size:22px; }

  .toolbar { display:flex; gap:10px; align-items:center; }
  .pill { background:var(--pill-bg); color:var(--pill-ink); padding:8px 12px; border-radius:10px; border:1px solid var(--border); cursor:pointer; font-size:14px; }
  .pill:active{ transform:translateY(1px); }

  main { max-width:900px; margin:20px auto; padding:12px; }
  .card { background:var(--card-bg); border:1px solid var(--border); border-radius:12px; padding:16px; margin-bottom:18px; }
  .row { display:flex; gap:10px; flex-wrap:wrap; }

  textarea { width:100%; min-height:260px; padding:10px; font-size:15px; border-radius:10px; border:1px solid var(--border); background:var(--opt-bg); color:var(--ink); }

  .q { padding:12px; border:1px solid var(--border); border-radius:12px; margin:10px 0; background:var(--card-bg); }
  .q > div:first-child { font-weight:600; margin-bottom:6px; }
  .opts { list-style:none; padding:0; margin:0; display:grid; gap:8px; }
  .opt { padding:8px; border:1px solid var(--border); border-radius:10px; background:var(--opt-bg); }
  .opt.correct { border-color:#2e7d32; }
  .opt.wrong { border-color:#c62828; }
</style>
</head>
<body>

<header>
  <div class="brand">
    <img src="mcq icon.png" alt="Logo">
    <h1>MCQ Q-Bank</h1>
  </div>
  <div class="toolbar">
    <button id="themeToggle" class="pill" title="Toggle light/dark">🌙</button>
    <span id="score" class="stats" style="margin-right:10px"></span>
    <span class="muted">Text</span>
    <div>
      <input id="mins" type="number" value="20" style="width:60px"> 
      <button id="tStart" class="pill">Start</button>
      <button id="tPause" class="pill">Pause</button>
      <button id="tReset" class="pill">Reset</button>
      <b id="tDisp">20:00</b>
    </div>
  </div>
</header>

<main>
  <div class="card">
    <p class="muted" style="margin:8px 0 6px"><b>Paste text MCQs</b></p>

    <div class="row" style="margin-top:8px">
      <input id="setTitle" placeholder="Saved set title" style="flex:1 1 320px" />
      <button id="saveSet" class="pill">💾 Save Set</button>
      <select id="savedList" style="min-width:160px"></select>
      <button id="deleteSet" class="pill">🗑️ Delete Set</button>
      <button id="exportSet" class="pill">⬇️ Export Set</button>
      <button id="exportAll" class="pill">⬇️ Export All</button>
      <input id="importSetFile" type="file" accept=".json" style="display:none" />
      <button id="importSet" class="pill">⬆️ Import Set</button>
      <input id="importBankFile" type="file" accept=".json" style="display:none" />
      <button id="importBank" class="pill">⬆️ Import Bank</button>
    </div>

    <div class="row" style="margin-top:8px">
      <input id="txtFile" type="file" accept=".txt,.md" />
      <button id="loadBtn" class="pill">📂 Load File</button>
      <button id="exampleBtn" class="pill">✨ Insert Example</button>
    </div>

    <textarea id="raw"></textarea>
    <div class="row" style="margin-top:10px">
      <button id="cleanBtn" class="pill">🧽 Clean</button>
      <button id="clearBtn" class="pill">🗑️ Clear box</button>
      <button id="parseBtn" class="pill">▶️ Parse → Start Quiz</button>
    </div>
    <div id="errBox" style="color:red;margin-top:10px"></div>
  </div>

  <div class="card" id="quizCard" style="display:none">
    <div id="quiz"></div>
  </div>

  <div class="card">
    <div class="row">
      <button id="finishBtn" class="pill" disabled>✅ Finish & Score</button>
      <button id="shuffleQ" class="pill">🔀 Shuffle Questions</button>
      <button id="shuffleO" class="pill">🔁 Shuffle Options</button>
      <button id="hardReset" class="pill">♻️ Reset</button>
    </div>
  </div>
</main>

<script>
const rawEl=document.getElementById('raw');
const quizCard=document.getElementById('quizCard');
const quizEl=document.getElementById('quiz');
const scoreEl=document.getElementById('score');
const txtFile = document.getElementById('txtFile');
const loadBtn = document.getElementById('loadBtn');

// ---- Saved sets (localStorage) ----
const LS_SETS_KEY = 'mcq-sets-v1';
function getSets(){ try { return JSON.parse(localStorage.getItem(LS_SETS_KEY)||'{}')||{}; } catch { return {}; } }
function putSets(sets){ localStorage.setItem(LS_SETS_KEY, JSON.stringify(sets)); }
function refreshSavedList(){
  const sel = document.getElementById('savedList');
  if (!sel) return;
  const sets = getSets();
  const titles = Object.keys(sets).sort((a,b)=>a.localeCompare(b));
  const current = sel.value;
  sel.innerHTML = '<option value="">Saved sets…</option>' +
                  titles.map(t=>`<option value="${t.replace(/"/g,'&amp;quot;')}">${t}</option>`).join('');
  if (current && titles.includes(current)) sel.value = current;
}
refreshSavedList();

// ---- Load file into textarea ----
(function bindFileLoader(){
  if (!txtFile) return;

  async function readPickedFile(file){
    if (!file) return;
    try {
      let text = await file.text();
      // optional: normalize the content for cleaner parsing
      text = normalize(text);
      rawEl.value = text;

      // Try to use filename as the default set title (without extension)
      const setTitleEl = document.getElementById('setTitle');
      if (setTitleEl && file.name) {
        const base = file.name.replace(/\.[^.]+$/, '').replace(/[_\-]+/g, ' ').trim();
        if (base && !setTitleEl.value) setTitleEl.value = base.slice(0, 60);
      }
    } catch (e) {
      const err = document.getElementById('errBox');
      if (err) err.textContent = 'Failed to read file: ' + (e?.message || e);
    }
  }

  // When user picks a file, read it immediately
  txtFile.addEventListener('change', (e)=>{
    const f = e.target.files && e.target.files[0];
    readPickedFile(f);
  });

  // Make the 'Load File' button open the file picker (in case user prefers button)
  if (loadBtn) {
    loadBtn.onclick = () => txtFile && txtFile.click();
  }
})();

// Save / load / delete / export
(function bindSavedSetButtons(){
  const setTitle = document.getElementById('setTitle');
  const savedList = document.getElementById('savedList');
  const saveBtn   = document.getElementById('saveSet');
  const delBtn    = document.getElementById('deleteSet');
  const exportBtn = document.getElementById('exportSet');
  const exportAll = document.getElementById('exportAll');

  function downloadText(filename, text){
    const blob = new Blob([text], { type:'text/plain' });
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = filename;
    a.click();
    setTimeout(()=>URL.revokeObjectURL(a.href), 1000);
  }

  if (saveBtn) saveBtn.onclick = ()=>{
    const title = (setTitle?.value||'').trim();
    const text  = (rawEl?.value||'').trim();
    if (!text) { alert('Nothing to save'); return; }
    if (!title){ alert('Enter a title'); return; }
    const sets = getSets();
    sets[title] = text;
    putSets(sets);
    refreshSavedList();
    savedList.value = title;
  };

  if (savedList) savedList.onchange = ()=>{
    const t = savedList.value;
    const sets = getSets();
    if (t && sets[t]){ rawEl.value = sets[t]; setTitle.value = t; }
  };

  if (delBtn) delBtn.onclick = ()=>{
    const t = savedList?.value || setTitle?.value || '';
    if (!t) { alert('Pick a saved set'); return; }
    const sets = getSets();
    if (!sets[t]) { alert('No such saved set'); return; }
    delete sets[t];
    putSets(sets);
    refreshSavedList();
    savedList.value = '';
  };

  if (exportBtn) exportBtn.onclick = ()=>{
    const t = savedList?.value || setTitle?.value || '';
    const sets = getSets();
    if (!t || !sets[t]) { alert('Pick a saved set'); return; }
    downloadText(`${t}.md`, sets[t]);
  };

  if (exportAll) exportAll.onclick = ()=>{
    const sets = getSets();
    const json = JSON.stringify(sets, null, 2);
    const stamp = new Date().toISOString().replace(/[:.]/g,'-');
    downloadText(`mcq_bank_${stamp}.json`, json);
  };
})();

const root=document.documentElement;
const THEME_KEY='mcq-theme';
if (!localStorage.getItem(THEME_KEY)) { document.documentElement.setAttribute('data-theme','light'); }
(function initTheme(){
  const saved=localStorage.getItem(THEME_KEY)||'light';
  root.setAttribute('data-theme', saved);
  const btn=document.getElementById('themeToggle');
  btn.textContent = saved==='light' ? '🌙' : '🌞';
  btn.onclick = () => {
    const next = (root.getAttribute('data-theme')==='light') ? 'dark' : 'light';
    root.setAttribute('data-theme', next);
    localStorage.setItem(THEME_KEY, next);
    btn.textContent = next==='light' ? '🌙' : '🌞';
  };
})();

function normalize(text){
  if (!text) return '';
  let t = String(text)
    .replace(/\uFEFF/g,'')                 // BOM
    .replace(/[\u200B-\u200D\u2060]/g,'')  // zero‑width
    .replace(/\r\n?/g,'\n')                // CRLF → LF
    .replace(/\u00A0/g,' ')                // NBSP
    .replace(/[“”]/g,'"').replace(/[‘’]/g,"'")
    .replace(/[–—]/g,'-')
    .replace(/^\s*(?:\*{3,}|-{3,}|_{3,})\s*$/gm,''); // horizontal rules

  // Insert newlines BEFORE inline option markers (A) / b. / C: with optional number/list prefix)
  t = t.replace(
    /(\S)\s+((?:\d+\s*[\)\.\-]\s*)?(?:[-–—•]\s*)?(?:\*\*)?\s*\(?[A-Da-d]\)?\s*[\)\.:]\s+(?=\S))/g,
    '$1\n$2'
  );
  // Newlines before Answer/Explanation labels (with possible bold, junk before colon)
  t = t.replace(
    /(\S)\s+((?:\*\*)?\s*(?:ans|answer|correct|exp|explanation)\b[^:]*[:=\-]\s*(?=\S))/ig,
    '$1\n$2'
  );

  // Collapse trailing spaces and mega blank lines
  t = t.replace(/[ \t]+\n/g,'\n').replace(/\n{3,}/g,'\n\n').trim();
  return t;
}

// helpers for safe rendering and Markdown inline formatting
function escapeHtml(s){return String(s).replace(/[&<>"']/g,m=>({"&":"&amp;","<":"&lt;",">":"&gt;","\"":"&quot;","'":"&#39;"}[m]));}
function mdInline(s){
  s = escapeHtml(String(s||''));
  s = s.replace(/\*\*(.+?)\*\*/g,'<b>$1</b>');
  s = s.replace(/(^|[\s>])_(?!\s)([^_\n]+?)_(?=($|[\s<]))/g,'$1<i>$2</i>');
  s = s.replace(/`([^`]+)`/g,'<code>$1</code>');
  return s;
}

// Parse
function parseMCQ(text){
  const T = normalize(text);
  const blocks = T.split(/\n{2,}/).map(b=>b.trim()).filter(Boolean);

  // Option lines like: "- A) foo", "a) bar", "B. baz", "(c) qux", "2) d: quux"
  const OPT_RE = /^\s*(?:\d+\s*[\)\.\-]\s*)?(?:[-–—•]\s*)?(?:\*\*)?\s*\(?([A-Da-d])\)?\s*[\)\.:\-]\s*(.+)$/;
  // Answer labels with bold/noise before colon: "**Answer**:", "Ans -", "correct:"
  const ANS_RE = /^\s*(?:\*\*)?\s*(?:ans|answer|correct)\b[^:]*[:=\-]\s*(.+)$/i;
  // Explanation labels (allow "exp:")
  const EXP_RE = /^\s*(?:\*\*)?\s*(?:exp|explanation)\b[^:]*[:=\-]\s*(.+)$/i;

  // Remove common leading "Q#/Q./1)" and markdown heading hashes
  const STRIP_Q_PREFIX = (s) => String(s)
      .replace(/^\s*#{1,6}\s*/, '')
      .replace(/^\s*(?:Q\s*\d*|Q|(\d+))\s*[\.\):]\s*/i, '')
      .trim();

  const items = [];

  for (const rawBlock of blocks){
    // Break into lines; if a single long line, try to split by option markers again
    let lines = rawBlock.split('\n').map(l=>l.trim()).filter(Boolean);
    if (lines.length === 1){
      const para = lines[0].replace(/\s{2,}/g,' ');
      const split = para.split(/\s(?=(?:\d+\s*[\)\.\-]\s*)?(?:[-–—•]\s*)?(?:\*\*)?\s*\(?[A-Da-d]\)?\s*[\)\.:]\s)/);
      if (split.length > 1) lines = [ split.shift(), ...split ];
    }

    // 1) Build stem until first option/label line
    const stemParts = [];
    while (lines.length && !OPT_RE.test(lines[0]) && !ANS_RE.test(lines[0]) && !EXP_RE.test(lines[0])){
      stemParts.push(STRIP_Q_PREFIX(lines.shift()));
    }
    let stem = stemParts.join(' ').trim();

    // 2) Options (A–D); keep order
    const options = [];
    while (lines.length && OPT_RE.test(lines[0])){
      const m = lines.shift().match(OPT_RE);
      options.push((m && m[2] ? m[2] : '').trim());
    }

    // 3) Answer + Explanation (any order, can span paragraphs)
    let ansPayload = '', explanation = '';
    while (lines.length){
      const L = lines.shift();
      let m;
      if ((m = L.match(ANS_RE))){ ansPayload = (m[1]||'').trim(); continue; }
      if ((m = L.match(EXP_RE))){ explanation = (m[1]||'').trim(); continue; }
      // Continuations
      if (explanation){ explanation += ' ' + L; }
      else if (options.length === 0){ stem += (stem ? ' ' : '') + STRIP_Q_PREFIX(L); }
    }

    // Rescue: if stem missing, rebuild from non-option/label content
    if (!stem){
      const rescue = rawBlock.split('\n')
        .filter(line => !OPT_RE.test(line) && !ANS_RE.test(line) && !EXP_RE.test(line))
        .map(STRIP_Q_PREFIX).join(' ').trim();
      stem = rescue;
    }

    // Need at least 2 options + non-empty stem
    if (!stem || options.length < 2) continue;

    // Resolve correct option index
    let correctIndex = -1;
    if (ansPayload){
      const letter = ansPayload.match(/\b([A-Da-d])\b/);
      if (letter){ correctIndex = letter[1].toUpperCase().charCodeAt(0) - 65; }
      if (correctIndex < 0){
        const norm = s => String(s).toLowerCase().replace(/\s+/g,' ').trim();
        const want = norm(ansPayload.replace(OPT_RE,'$2'));
        options.forEach((o,i) => { if (norm(o) === want) correctIndex = i; });
        if (correctIndex < 0){
          options.forEach((o,i) => { const n=norm(o); if (n.includes(want) || want.includes(n)) correctIndex = i; });
        }
      }
    }
    if (correctIndex < 0) correctIndex = 0; // safe default when answer is missing

    items.push({ stem, options, correctIndex, explanation });
  }

  return items;
}

function renderQuiz(){
  quizEl.innerHTML=QUIZ.map((q,i)=>`
    <div class="q">
      <div>${i+1}. ${mdInline(q.stem)}</div>
      <ul class="opts">
        ${q.options.map((o,j)=>{
          let cls="opt";
          if(FINISHED){ if(j===q.correctIndex) cls+=" correct"; else if(ANSWERS[i]===j) cls+=" wrong"; }
          return `<li class="${cls}">
            <label><input type="radio" name="q${i}" value="${j}" ${ANSWERS[i]===j?"checked":""} ${FINISHED?"disabled":""}>
            ${String.fromCharCode(65+j)}) ${mdInline(o)}</label>
          </li>`;
        }).join("")}
      </ul>
      ${FINISHED?`<div><b>Explanation:</b> ${mdInline(q.explanation||"")}</div>`:""}
    </div>
  `).join("");
  quizEl.querySelectorAll('input[type="radio"]').forEach(inp=>{
    inp.onchange=()=>{ const idx=+inp.name.replace("q",""); ANSWERS[idx]=+inp.value; updateScore(); };
  });
}
function updateScore(){
  let c=0,w=0,s=0;
  QUIZ.forEach((q,i)=>{ const a=ANSWERS[i]; if(a==null) s++; else if(a===q.correctIndex) c++; else w++; });
  scoreEl.textContent=`Answered: ${QUIZ.length-s}/${QUIZ.length} • Correct: ${c} • Wrong: ${w}`;
}

// UI
document.getElementById('parseBtn').onclick=()=>{
  const err = document.getElementById('errBox');
  err.textContent = '';
  QUIZ = parseMCQ(rawEl.value||"");
  if (!QUIZ.length){
    err.textContent = "Parsing failed. Try: ensure options are labelled A)/B)/C)/D) and there is an Answer:. Bold/paragraph formats are supported—if this still fails, paste one sample here and I'll tune it.";
    quizCard.style.display="none";
    scoreEl.textContent="";
    return;
  }

  // Enable Finish button and auto-start timer (1 min per question, min 1)
  const finishBtnEl = document.getElementById('finishBtn');
  if (finishBtnEl) finishBtnEl.disabled = false;

  const perQ = Math.max(1, QUIZ.length);
  const minsInput = document.getElementById('mins');
  if (minsInput) minsInput.value = perQ;
  try { startTimer(perQ); } catch(e){}

  quizCard.style.display="block";
  FINISHED=false; ANSWERS={};
  renderQuiz(); updateScore();
};
document.getElementById('finishBtn').onclick=()=>{FINISHED=true; renderQuiz();};
document.getElementById('shuffleQ').onclick=()=>{QUIZ.sort(()=>Math.random()-.5); renderQuiz();};
document.getElementById('shuffleO').onclick=()=>{QUIZ.forEach(q=>{q.options.sort(()=>Math.random()-.5)}); renderQuiz();};
document.getElementById('hardReset').onclick=()=>{QUIZ=[];ANSWERS={};FINISHED=false;quizCard.style.display="none";scoreEl.textContent="";};
document.getElementById('exampleBtn').onclick=()=>{rawEl.value="Q1. Example question?\nA) One\nB) Two\nC) Three\nD) Four\nAnswer: B\nExplanation: Demo";};
document.getElementById('cleanBtn').onclick=()=>{rawEl.value=normalize(rawEl.value);};
document.getElementById('clearBtn').onclick=()=>{ rawEl.value=''; rawEl.focus(); };

// Timer
const mins=document.getElementById('mins'),tDisp=document.getElementById('tDisp'); let tick=null,deadline=0;
const fmt=s=>{ const ss=Math.max(0, Math.floor(s)); return `${String(Math.floor(ss/60)).padStart(2,'0')}:${String(ss%60).padStart(2,'0')}`; };
function startTimer(m){deadline=Date.now()+m*60*1000;if(tick)clearInterval(tick);tick=setInterval(()=>{let s=Math.max(0,Math.ceil((deadline-Date.now())/1000));tDisp.textContent=fmt(s);if(s<=0){clearInterval(tick);}},1000);}
document.getElementById('tStart').onclick=()=>startTimer(+mins.value||20);
document.getElementById('tPause').onclick=()=>clearInterval(tick);
document.getElementById('tReset').onclick=()=>{clearInterval(tick);tDisp.textContent=fmt((+mins.value||20)*60); try{ updateScore(); }catch{};};
</script>

</body>
</html>
