<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />

<title>MCQ Q-Bank</title>

<!-- PWA manifest & theme -->
<link rel="manifest" href="manifest.json">
<meta name="theme-color" content="#1f6feb">
<!-- Optional favicons (ensure these files exist in the same folder) -->
<link rel="icon" type="image/png" sizes="192x192" href="mcq icon.png">
<link rel="icon" type="image/png" sizes="512x512" href="logo 2.png">

<style>
  :root{
    --bg:#f9f9f9; --ink:#222;
    --header-bg:#1f6feb; --header-ink:#ffffff;
    --card-bg:#ffffff; --border:#dddddd;
    --opt-bg:#f5f5f5;
    --pill-bg:#ffffff; --pill-ink:#1f6feb;
  }
  [data-theme="dark"]{
    --bg:#0f1115; --ink:#e6e6e6;
    --header-bg:#111827; --header-ink:#e6e6e6;
    --card-bg:#171a21; --border:#2a2e3a;
    --opt-bg:#0f1219;
    --pill-bg:#0f1219; --pill-ink:#e6e6e6;
  }

  *{ box-sizing:border-box }
  body { margin:0; font-family: system-ui, sans-serif; background:var(--bg); color:var(--ink); }
  header { display:flex; justify-content:space-between; align-items:center; padding:12px 18px; background:var(--header-bg); color:var(--header-ink); position:sticky; top:0; z-index:10; }
  header .brand { display:flex; align-items:center; gap:12px; }
  header img { width:64px; height:64px; border-radius:12px; background:#fff; padding:6px; box-shadow:0 4px 14px rgba(0,0,0,.18); }
  header h1 { margin:0; font-size:22px; }

  .toolbar { display:flex; gap:10px; align-items:center; }
  .pill { background:var(--pill-bg); color:var(--pill-ink); padding:8px 12px; border-radius:10px; border:1px solid var(--border); cursor:pointer; font-size:14px; }
  .pill:active{ transform:translateY(1px); }

  main { max-width:900px; margin:20px auto; padding:12px; }
  .card { background:var(--card-bg); border:1px solid var(--border); border-radius:12px; padding:16px; margin-bottom:18px; }
  .row { display:flex; gap:10px; flex-wrap:wrap; }

  textarea { width:100%; min-height:260px; padding:10px; font-size:15px; border-radius:10px; border:1px solid var(--border); background:var(--opt-bg); color:var(--ink); }

  .q { padding:12px; border:1px solid var(--border); border-radius:12px; margin:10px 0; background:var(--card-bg); }
  .q > div:first-child { font-weight:600; margin-bottom:6px; }
  .opts { list-style:none; padding:0; margin:0; display:grid; gap:8px; }
  .opt { padding:8px; border:1px solid var(--border); border-radius:10px; background:var(--opt-bg); }
  .opt.correct { border-color:#2e7d32; }
  .opt.wrong { border-color:#c62828; }
</style>
</head>
<body>

<header>
  <div class="brand">
    <img src="mcq icon.png" alt="Logo">
    <h1>MCQ Q-Bank</h1>
  </div>
  <div class="toolbar">
    <button id="themeToggle" class="pill" title="Toggle light/dark">🌙</button>
    <button id="installBtn" class="pill" style="display:none" title="Install as app">📥 Install</button>
    <span id="score" class="stats" style="margin-right:10px"></span>
    <span class="muted">Text</span>
    <div>
      <input id="mins" type="number" value="20" style="width:60px"> 
      <button id="tStart" class="pill">Start</button>
      <button id="tPause" class="pill">Pause</button>
      <button id="tReset" class="pill">Reset</button>
      <b id="tDisp">20:00</b>
    </div>
  </div>
</header>

<main>
  <div class="card">
    <p class="muted" style="margin:8px 0 6px"><b>Paste text MCQs</b></p>

    <div class="row" style="margin-top:8px">
      <input id="setTitle" placeholder="Saved set title" style="flex:1 1 320px" />
      <button id="saveSet" class="pill">💾 Save Set</button>
      <select id="savedList" style="min-width:160px"></select>
      <button id="deleteSet" class="pill">🗑️ Delete Set</button>
      <button id="exportSet" class="pill">⬇️ Export Set</button>
      <button id="exportAll" class="pill">⬇️ Export All</button>
      <input id="importSetFile" type="file" accept=".json" style="display:none" />
      <button id="importSet" class="pill">⬆️ Import Set</button>
      <input id="importBankFile" type="file" accept=".json" style="display:none" />
      <button id="importBank" class="pill">⬆️ Import Bank</button>
    </div>

    <div class="row" style="margin-top:8px">
      <input id="txtFile" type="file" accept=".txt,.md" />
      <button id="loadBtn" class="pill">📂 Load File</button>
      <button id="exampleBtn" class="pill">✨ Insert Example</button>
    </div>

    <textarea id="raw"></textarea>
    <div class="row" style="margin-top:10px">
      <button id="cleanBtn" class="pill">🧽 Clean</button>
      <button id="clearBtn" class="pill">🗑️ Clear box</button>
      <button id="parseBtn" class="pill">▶️ Parse → Start Quiz</button>
    </div>
    <div id="errBox" style="color:red;margin-top:10px"></div>
  </div>

  <div class="card" id="quizCard" style="display:none">
    <div id="quiz"></div>
  </div>

  <div class="card">
    <div class="row">
      <button id="finishBtn" class="pill" disabled>✅ Finish & Score</button>
      <button id="shuffleQ" class="pill">🔀 Shuffle Questions</button>
      <button id="shuffleO" class="pill">🔁 Shuffle Options</button>
      <button id="hardReset" class="pill">♻️ Reset</button>
    </div>
  </div>
</main>

<script>
const rawEl=document.getElementById('raw');
const quizCard=document.getElementById('quizCard');
const quizEl=document.getElementById('quiz');
const scoreEl=document.getElementById('score');
const txtFile = document.getElementById('txtFile');
const loadBtn = document.getElementById('loadBtn');

// ---- Global quiz state ----
let QUIZ = [];
let ANSWERS = {};
let FINISHED = false;

// ---- Saved sets (localStorage) ----
const LS_SETS_KEY = 'mcq-sets-v1';
function getSets(){ try { return JSON.parse(localStorage.getItem(LS_SETS_KEY)||'{}')||{}; } catch { return {}; } }
function putSets(sets){ localStorage.setItem(LS_SETS_KEY, JSON.stringify(sets)); }
function refreshSavedList(){
  const sel = document.getElementById('savedList');
  if (!sel) return;
  const sets = getSets();
  const titles = Object.keys(sets).sort((a,b)=>a.localeCompare(b));
  const current = sel.value;
  sel.innerHTML = '<option value="">Saved sets…</option>' +
                  titles.map(t=>`<option value="${t.replace(/"/g,'&amp;quot;')}">${t}</option>`).join('');
  if (current && titles.includes(current)) sel.value = current;
}
refreshSavedList();

// ---- Load file into textarea ----
(function bindFileLoader(){
  if (!txtFile) return;

  async function readPickedFile(file){
    if (!file) return;
    try {
      let text = await file.text();
      // optional: normalize the content for cleaner parsing
      text = normalize(text);
      rawEl.value = text;

      // Try to use filename as the default set title (without extension)
      const setTitleEl = document.getElementById('setTitle');
      if (setTitleEl && file.name) {
        const base = file.name.replace(/\.[^.]+$/, '').replace(/[_\-]+/g, ' ').trim();
        if (base && !setTitleEl.value) setTitleEl.value = base.slice(0, 60);
      }
    } catch (e) {
      const err = document.getElementById('errBox');
      if (err) err.textContent = 'Failed to read file: ' + (e?.message || e);
    }
  }

  // When user picks a file, read it immediately
  txtFile.addEventListener('change', (e)=>{
    const f = e.target.files && e.target.files[0];
    readPickedFile(f);
  });

  // Make the 'Load File' button open the file picker (in case user prefers button)
  if (loadBtn) {
    loadBtn.onclick = () => txtFile && txtFile.click();
  }
})();

// Save / load / delete / export
(function bindSavedSetButtons(){
  const setTitle = document.getElementById('setTitle');
  const savedList = document.getElementById('savedList');
  const saveBtn   = document.getElementById('saveSet');
  const delBtn    = document.getElementById('deleteSet');
  const exportBtn = document.getElementById('exportSet');
  const exportAll = document.getElementById('exportAll');

  function downloadText(filename, text){
    const blob = new Blob([text], { type:'text/plain' });
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = filename;
    a.click();
    setTimeout(()=>URL.revokeObjectURL(a.href), 1000);
  }

  if (saveBtn) saveBtn.onclick = ()=>{
    const title = (setTitle?.value||'').trim();
    const text  = (rawEl?.value||'').trim();
    if (!text) { alert('Nothing to save'); return; }
    if (!title){ alert('Enter a title'); return; }
    const sets = getSets();
    sets[title] = text;
    putSets(sets);
    refreshSavedList();
    savedList.value = title;
  };

  if (savedList) savedList.onchange = ()=>{
    const t = savedList.value;
    const sets = getSets();
    if (t && sets[t]){ rawEl.value = sets[t]; setTitle.value = t; }
  };

  if (delBtn) delBtn.onclick = ()=>{
    const t = savedList?.value || setTitle?.value || '';
    if (!t) { alert('Pick a saved set'); return; }
    const sets = getSets();
    if (!sets[t]) { alert('No such saved set'); return; }
    delete sets[t];
    putSets(sets);
    refreshSavedList();
    savedList.value = '';
  };

  if (exportBtn) exportBtn.onclick = ()=>{
    const t = savedList?.value || setTitle?.value || '';
    const sets = getSets();
    if (!t || !sets[t]) { alert('Pick a saved set'); return; }
    downloadText(`${t}.md`, sets[t]);
  };

  if (exportAll) exportAll.onclick = ()=>{
    const sets = getSets();
    const json = JSON.stringify(sets, null, 2);
    const stamp = new Date().toISOString().replace(/[:.]/g,'-');
    downloadText(`mcq_bank_${stamp}.json`, json);
  };
})();

const root=document.documentElement;
const THEME_KEY='mcq-theme';
if (!localStorage.getItem(THEME_KEY)) { document.documentElement.setAttribute('data-theme','light'); }
(function initTheme(){
  const saved=localStorage.getItem(THEME_KEY)||'light';
  root.setAttribute('data-theme', saved);
  const btn=document.getElementById('themeToggle');
  btn.textContent = saved==='light' ? '🌙' : '🌞';
  btn.onclick = () => {
    const next = (root.getAttribute('data-theme')==='light') ? 'dark' : 'light';
    root.setAttribute('data-theme', next);
    localStorage.setItem(THEME_KEY, next);
    btn.textContent = next==='light' ? '🌙' : '🌞';
  };
})();

function normalize(text){
  if (!text) return '';
  let t = String(text)
    .replace(/\uFEFF/g,'')                 // BOM
    .replace(/[\u200B-\u200D\u2060]/g,'')  // zero‑width
    .replace(/\r\n?/g,'\n')                // CRLF → LF
    .replace(/\u00A0/g,' ')                // NBSP
    .replace(/[“”]/g,'"').replace(/[‘’]/g,"'")
    .replace(/[–—]/g,'-')
    .replace(/^\s*(?:\*{3,}|-{3,}|_{3,})\s*$/gm,''); // horizontal rules

  // Insert newlines BEFORE inline option markers (A) / b. / C: with optional number/list prefix)
  t = t.replace(
    /(\S)\s+((?:\d+\s*[\)\.\-]\s*)?(?:[-–—•]\s*)?(?:\*\*)?\s*\(?[A-Da-d]\)?\s*[\)\.:]\s+(?=\S))/g,
    '$1\n$2'
  );
  // Newlines before Answer/Explanation labels (with possible bold, junk before colon)
  t = t.replace(
    /(\S)\s+((?:\*\*)?\s*(?:ans|answer|correct|exp|explanation)\b[^:]*[:=\-]\s*(?=\S))/ig,
    '$1\n$2'
  );

  // If "Answer:" is followed by a bare letter stuck to the same line without space (rare OCR),
  // add a space so our regex picks it up.
  t = t.replace(/(answer\b[^:]*[:=\-])([A-Da-d])\b/ig, '$1 $2');

  // Collapse trailing spaces and mega blank lines
  t = t.replace(/[ \t]+\n/g,'\n').replace(/\n{3,}/g,'\n\n').trim();
  return t;
}

// helpers for safe rendering and Markdown inline formatting
function escapeHtml(s){return String(s).replace(/[&<>"']/g,m=>({"&":"&amp;","<":"&lt;",">":"&gt;","\"":"&quot;","'":"&#39;"}[m]));}
function mdInline(s){
  s = escapeHtml(String(s||''));
  s = s.replace(/\*\*(.+?)\*\*/g,'<b>$1</b>');
  s = s.replace(/(^|[\s>])_(?!\s)([^_\n]+?)_(?=($|[\s<]))/g,'$1<i>$2</i>');
  s = s.replace(/`([^`]+)`/g,'<code>$1</code>');
  return s;
}

// Parse
function parseMCQ(text){
  window.__parseErrors = [];
  const T = normalize(text);
  const blocks = T.split(/\n{2,}/).map(b=>b.trim()).filter(Boolean);

  // Option lines like: "- A) foo", "a) bar", "B. baz", "(c) qux", "2) d: quux"
  const OPT_RE = /^\s*(?:\d+\s*[\)\.\-]\s*)?(?:[-–—•]\s*)?(?:\*\*)?\s*\(?([A-Da-d])\)?\s*[\)\.:\-]\s*(.+)$/;
  // Answer labels with bold/noise before colon: "**Answer**:", "Ans -", "correct:"
  const ANS_RE = /^\s*(?:\*\*)?\s*(?:ans|answer|correct)\b[^:]*[:=\-]\s*(.*)$/i;
  // Explanation labels (allow "exp:")
  const EXP_RE = /^\s*(?:\*\*)?\s*(?:exp|explanation)\b[^:]*[:=\-]\s*(.+)$/i;

  // Remove common leading "Q#/Q./1)" and markdown heading hashes
  const STRIP_Q_PREFIX = (s) => String(s)
      .replace(/^\s*#{1,6}\s*/, '')
      .replace(/^\s*(?:Q\s*\d*|Q|(\d+))\s*[\.\):]\s*/i, '')
      .trim();

  // --- Helper functions for answer/option cleaning & matching ---
  // Keep the intended A–D answer even if OCR added junk, markdown, etc.
  function cleanAnswerPayload(p){
    if (!p) return '';
    let s = String(p).trim();

    // Strip markdown and common wrappers
    s = s.replace(/\*\*|__/g, '').replace(/`/g, '');

    // Remove surrounding quotes/brackets and trailing references e.g. [1], (ref)
    s = s.replace(/^[\s"'\(\[\{]+/, '').replace(/[\s"'\)\]\}]+$/, '');
    s = s.replace(/[\(\[\{][^()\[\]{}]*[\)\]\}]\s*$/g, '');

    // Normalize separators like "Ans wer: B" -> try to keep only payload
    s = s.replace(/\b(answer|ans|correct)\b[^:]*:\s*/i, '');

    // If starts with "B)"/"B."/"(B)" capture the letter
    let m = s.match(/^\s*\(?\s*([A-Da-d])\s*\)?\s*[\)\.\-:]/);
    if (m) return m[1].toUpperCase();

    // If contains a standalone letter near the end (handles OCR junk)
    m = s.match(/([A-Da-d])(?:\s*[\*\)\]\.:\-]*)\s*$/);
    if (m) return m[1].toUpperCase();

    // Any isolated letter token
    m = s.match(/\b([A-Da-d])\b/);
    if (m) return m[1].toUpperCase();

    // Otherwise return the cleaned text so we can fuzzy-match to option text
    return s.trim();
  }

  function resolveCorrectIndex(options, rawPayload){
    if (!options?.length) return -1;

    const payload = cleanAnswerPayload(rawPayload);

    // If payload is A–D letter, return directly
    if (/^[A-D]$/.test(payload)) {
      const idx = payload.charCodeAt(0) - 65;
      return (idx >= 0 && idx < options.length) ? idx : -1;
    }

    // Normalize function for better fuzzy matching
    const norm = (s) => String(s||'')
      .toLowerCase()
      .replace(/\*\*|__/g,'')
      .replace(/`/g,'')
      .replace(/[“”]/g,'"').replace(/[‘’]/g,"'")
      .replace(/[–—]/g,'-')
      .replace(/[\s\.\,\;\:\!\?\(\)\[\]\{\}"'`]+/g,' ') // punctuation -> space
      .replace(/\s+/g,' ')
      .trim();

    const want = norm(payload);

    // Build candidate scores against each option
    let bestIdx = -1;
    let bestScore = -1;

    options.forEach((o, i) => {
      const n = norm(o);

      if (!n || !want) return;

      // Exact match
      if (n === want) {
        if (bestScore < 100) { bestScore = 100; bestIdx = i; }
        return;
      }

      // Contains either way
      if (n.includes(want) || want.includes(n)) {
        const score = Math.min(n.length, want.length); // longer overlap = higher
        if (score > bestScore) { bestScore = score; bestIdx = i; }
        return;
      }

      // Token overlap (Jaccard-like)
      const a = new Set(n.split(' '));
      const b = new Set(want.split(' '));
      const inter = [...a].filter(t => b.has(t)).length;
      const union = new Set([...a, ...b]).size || 1;
      const j = inter / union; // 0..1
      const score = j * 50 + inter; // weight
      if (score > bestScore) { bestScore = score; bestIdx = i; }
    });

    return bestIdx;
  }

  const items = [];

  for (const rawBlock of blocks){
    // Break into lines; if a single long line, try to split by option markers again
    let lines = rawBlock.split('\n').map(l=>l.trim()).filter(Boolean);
    if (lines.length === 1){
      const para = lines[0].replace(/\s{2,}/g,' ');
      const split = para.split(/\s(?=(?:\d+\s*[\)\.\-]\s*)?(?:[-–—•]\s*)?(?:\*\*)?\s*\(?[A-Da-d]\)?\s*[\)\.:]\s)/);
      if (split.length > 1) lines = [ split.shift(), ...split ];
    }

    // 1) Build stem until first option/label line
    const stemParts = [];
    while (lines.length && !OPT_RE.test(lines[0]) && !ANS_RE.test(lines[0]) && !EXP_RE.test(lines[0])){
      stemParts.push(STRIP_Q_PREFIX(lines.shift()));
    }
    let stem = stemParts.join(' ').trim();

    // 2) Options (A–D); keep order
    const optLines = [];
    while (lines.length && OPT_RE.test(lines[0])){
      const m = lines.shift().match(OPT_RE);
      optLines.push((m && m[2] ? m[2] : '').trim());
    }
    // Normalize option text for robust matching
    const options = optLines.map(s =>
      String(s || '')
        .replace(/\*\*|__/g,'')
        .replace(/`/g,'')
        .replace(/[“”]/g,'"').replace(/[‘’]/g,"'")
        .replace(/[–—]/g,'-')
        .replace(/\s+/g,' ')
        .trim()
    );

    // 3) Answer + Explanation (any order, can span paragraphs)
    let ansPayload = '', explanation = '';
    let awaitingAnswerContinuation = false;
    while (lines.length){
      const L = lines.shift();
      let m;

      // Answer label
      if ((m = L.match(ANS_RE))){
        ansPayload = (m[1] ?? '').trim();

        // If payload is empty, try to read from the very next line(s)
        if (!ansPayload && lines.length){
          const peek = (s) => String(s || '').trim();
          let nxt = peek(lines[0]);

          // Case 1: next line is a bare letter like "B" or "(b)" or "B)" etc.
          let mm = nxt.match(/^\s*\(?\s*([A-Da-d])\s*\)?\s*[\)\.:\-]?\s*$/);
          if (mm){
            ansPayload = mm[1].toUpperCase();
            lines.shift(); // consume the line
            continue;
          }

          // Case 2: next line is a full option line, e.g. "- B) Glucocorticoids"
          mm = nxt.match(OPT_RE);
          if (mm){
            // Prefer the option LETTER if present; otherwise the option text for fuzzy match
            ansPayload = (mm[1] ? mm[1].toUpperCase() : (mm[2] || '')).trim();
            lines.shift(); // consume the line
            continue;
          }

          // Case 3: next line is free text (e.g., the exact option phrase)
          if (nxt){
            ansPayload = nxt;
            lines.shift();
            continue;
          }
        }
        // If we had non-empty payload, proceed
        continue;
      }

      // Explanation label
      if ((m = L.match(EXP_RE))){
        explanation = (m[1] || '').trim();
        // absorb following free-text lines into explanation until another label is hit
        while (lines.length && !ANS_RE.test(lines[0]) && !OPT_RE.test(lines[0])){
          const cont = lines[0].trim();
          if (cont) { explanation += (explanation ? ' ' : '') + cont; }
          lines.shift();
        }
        continue;
      }

      // Continuations:
      if (explanation){
        explanation += ' ' + L;
      } else if (options.length === 0){
        // If options were never captured (rare paragraph style), keep extending stem
        stem += (stem ? ' ' : '') + STRIP_Q_PREFIX(L);
      }
    }

    // Rescue: if stem missing, rebuild from non-option/label content
    if (!stem){
      const rescue = rawBlock.split('\n')
        .filter(line => !OPT_RE.test(line) && !ANS_RE.test(line) && !EXP_RE.test(line))
        .map(STRIP_Q_PREFIX).join(' ').trim();
      stem = rescue;
    }

    // Need at least 2 options + non-empty stem
    if (!stem || options.length < 2) continue;

    // Resolve correct option index
    let correctIndex = -1;
    if (ansPayload){
      let payload = ansPayload;
      payload = cleanAnswerPayload(payload);
      correctIndex = resolveCorrectIndex(options, /^[A-Da-d]$/.test(payload) ? payload.toUpperCase() : payload);
    }
    if (correctIndex < 0) {
      // Do NOT default to A. Surface an error and skip this item.
      const previewStem = (stem || '').slice(0, 80);
      const previewAns  = (ansPayload || '').slice(0, 40);
      console.warn('Answer could not be resolved for:', previewStem, 'payload:', previewAns);
      try {
        (window.__parseErrors ||= []).push(`Could not resolve answer for: "${previewStem}" (Answer: ${previewAns || '—'})`);
      } catch {}
      continue;
    }

    items.push({ stem, options, correctIndex, explanation });
  }

  try {
    const eb = document.getElementById('errBox');
    if (eb && window.__parseErrors.length) {
      eb.style.color = 'red';
      eb.innerHTML = '<b>Parsing issues:</b><br>' + window.__parseErrors.map(e => '• ' + e).join('<br>');
    }
  } catch {}
  return items;
}

function renderQuiz(){
  quizEl.innerHTML=QUIZ.map((q,i)=>`
    <div class="q">
      <div>${i+1}. ${mdInline(q.stem)}</div>
      <ul class="opts">
        ${q.options.map((opt,j)=>{
          let cls="opt";
          if(FINISHED){ if(j===q.correctIndex) cls+=" correct"; else if(ANSWERS[i]===j) cls+=" wrong"; }
          return `<li class="${cls}">
            <label><input type="radio" name="q${i}" value="${j}" ${ANSWERS[i]===j?"checked":""} ${FINISHED?"disabled":""}>
            ${String.fromCharCode(65+j)}) ${mdInline(String(opt || ''))}</label>
          </li>`;
        }).join("")}
      </ul>
      ${FINISHED?`<div><b>Explanation:</b> ${mdInline(q.explanation||"")}</div>`:""}
    </div>
  `).join("");
  quizEl.querySelectorAll('input[type="radio"]').forEach(inp=>{
    inp.onchange=()=>{ const idx=+inp.name.replace("q",""); ANSWERS[idx]=+inp.value; updateScore(); };
  });
}
function updateScore(){
  let c=0,w=0,s=0;
  QUIZ.forEach((q,i)=>{ const a=ANSWERS[i]; if(a==null) s++; else if(a===q.correctIndex) c++; else w++; });
  scoreEl.textContent=`Answered: ${QUIZ.length-s}/${QUIZ.length} • Correct: ${c} • Wrong: ${w}`;
}

// UI
document.getElementById('parseBtn').onclick=()=>{
  const err = document.getElementById('errBox');
  err.textContent = '';
  QUIZ = parseMCQ(rawEl.value||"");
  // Show errBox if errors were collected
  const eb = document.getElementById('errBox');
  if (eb && window.__parseErrors && window.__parseErrors.length) {
    eb.style.display = 'block';
  }
  if (!QUIZ.length){
    if (!window.__parseErrors || !window.__parseErrors.length) {
      err.textContent = "Parsing failed. Ensure options are A)/B)/C)/D) and include an Answer:. If this still fails, paste one sample and I'll tune it.";
    }
    quizCard.style.display="none";
    scoreEl.textContent="";
    return;
  }

  // Enable Finish button and auto-start timer (1 min per question, min 1)
  const finishBtnEl = document.getElementById('finishBtn');
  if (finishBtnEl) finishBtnEl.disabled = false;

  const perQ = Math.max(1, QUIZ.length);
  const minsInput = document.getElementById('mins');
  if (minsInput) minsInput.value = perQ;
  try { startTimer(perQ); } catch(e){}

  quizCard.style.display="block";
  FINISHED=false; ANSWERS={};
  renderQuiz(); updateScore();
};
document.getElementById('finishBtn').onclick = () => {
  // Pause/stop the countdown but keep the remaining time visible
  try { clearInterval(tick); } catch {}
  tick = null;

  // Show results
  FINISHED = true;
  renderQuiz();
};
document.getElementById('shuffleQ').onclick = () => {
  if (!QUIZ.length) return;
  // Fisher–Yates
  for (let i = QUIZ.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [QUIZ[i], QUIZ[j]] = [QUIZ[j], QUIZ[i]];
  }
  // Clear previous picks because indices changed
  ANSWERS = {};
  FINISHED = false;
  renderQuiz();
  updateScore();
};

document.getElementById('shuffleO').onclick = () => {
  if (!QUIZ.length) return;
  QUIZ.forEach(q => {
    const order = q.options.map((_, idx) => idx);
    // Fisher–Yates on the index order
    for (let i = order.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [order[i], order[j]] = [order[j], order[i]];
    }
    // Reorder options using the shuffled indices
    q.options = order.map(idx => q.options[idx]);
    // Update the correctIndex to the new position of the former correct option
    q.correctIndex = order.indexOf(q.correctIndex);
  });
  // Clear any previous selections since option positions changed
  ANSWERS = {};
  FINISHED = false;
  renderQuiz();
  updateScore();
};
document.getElementById('hardReset').onclick=()=>{QUIZ=[];ANSWERS={};FINISHED=false;quizCard.style.display="none";scoreEl.textContent="";};
document.getElementById('exampleBtn').onclick=()=>{rawEl.value="Q1. Example question?\nA) One\nB) Two\nC) Three\nD) Four\nAnswer: B\nExplanation: Demo";};
document.getElementById('cleanBtn').onclick=()=>{rawEl.value=normalize(rawEl.value);};
document.getElementById('clearBtn').onclick=()=>{ rawEl.value=''; rawEl.focus(); };

// Timer
const mins=document.getElementById('mins'),tDisp=document.getElementById('tDisp'); let tick=null,deadline=0;
const fmt=s=>{ const ss=Math.max(0, Math.floor(s)); return `${String(Math.floor(ss/60)).padStart(2,'0')}:${String(ss%60).padStart(2,'0')}`; };
function startTimer(m){deadline=Date.now()+m*60*1000;if(tick)clearInterval(tick);tick=setInterval(()=>{let s=Math.max(0,Math.ceil((deadline-Date.now())/1000));tDisp.textContent=fmt(s);if(s<=0){clearInterval(tick);}},1000);}
document.getElementById('tStart').onclick=()=>startTimer(+mins.value||20);
document.getElementById('tPause').onclick=()=>clearInterval(tick);
document.getElementById('tReset').onclick=()=>{clearInterval(tick);tDisp.textContent=fmt((+mins.value||20)*60); try{ updateScore(); }catch{};};
</script>

</script>

<script>
// PWA install button logic (shows when site is installable over HTTPS/localhost)
(function(){
  let deferredPrompt = null;
  const btn = document.getElementById('installBtn');

  window.addEventListener('beforeinstallprompt', (e) => {
    // Prevent the mini-infobar on mobile and store event
    e.preventDefault();
    deferredPrompt = e;
    if (btn) btn.style.display = '';
  });

  if (btn) {
    btn.addEventListener('click', async () => {
      if (!deferredPrompt) return;
      deferredPrompt.prompt();
      try {
        const choice = await deferredPrompt.userChoice;
        // Hide button if accepted
        if (choice && choice.outcome === 'accepted') {
          btn.style.display = 'none';
        }
      } catch {}
      deferredPrompt = null;
    });
  }

  window.addEventListener('appinstalled', () => {
    if (btn) btn.style.display = 'none';
    console.log('PWA installed');
  });
})();
</script>

<script>
// Register Service Worker for PWA install/offline
if ('serviceWorker' in navigator) {
  navigator.serviceWorker.register('./sw.js')
    .then(reg => {
      console.log('SW registered', reg.scope || '');
    })
    .catch(err => console.error('SW registration failed:', err));
}
</script>

</body>
</html>
